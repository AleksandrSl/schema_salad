# Stubs for mistune (Python 3.5)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional, Pattern, List, AnyStr, Tuple, Dict, Union


def escape(text: str, quote: bool = ..., smart_amp: bool = ...): ...

class BlockGrammar:
    def_links = ...  # type: Pattern
    def_footnotes = ...  # type: Pattern
    newline = ...  # type: Pattern
    block_code = ...  # type: Pattern
    fences = ...  # type: Pattern
    hrule = ...  # type: Pattern
    heading = ...  # type: Pattern
    lheading = ...  # type: Pattern
    block_quote = ...  # type: Pattern
    list_block = ...  # type: Pattern
    list_item = ...  # type: Pattern
    list_bullet = ...  # type: Pattern
    paragraph = ...  # type: Pattern
    block_html = ...  # type: Pattern
    table = ...  # type: Pattern
    nptable = ...  # type: Pattern
    text = ...  # type: Pattern

class BlockLexer:
    grammar_class = ...  # type: BlockGrammar
    default_rules = ...  # type: List[AnyStr]
    list_rules = ...  # type: Tuple[AnyStr]
    footnote_rules = ...  # type: Tuple[AnyStr]
    tokens = ...  # type: List[Dict[Any]]
    def_links = ...  # type: Dict[Any]
    def_footnotes = ...  # type: Dict[Any]
    rules = ...  # type: Union[BlockGrammar, Any]
    def __init__(self, rules: Optional[Any] = ..., **kwargs) -> None: ...
    def __call__(self, text: AnyStr, rules: Optional[Any] = ...): ...
    def parse(self, text: AnyStr, rules: Optional[Any] = ...) -> List[Dict[Any]]: ...
    def parse_newline(self, m): ...
    def parse_block_code(self, m): ...
    def parse_fences(self, m): ...
    def parse_heading(self, m): ...
    def parse_lheading(self, m): ...
    def parse_hrule(self, m): ...
    def parse_list_block(self, m): ...
    def parse_block_quote(self, m): ...
    def parse_def_links(self, m): ...
    def parse_def_footnotes(self, m): ...
    def parse_table(self, m): ...
    def parse_nptable(self, m): ...
    def parse_block_html(self, m): ...
    def parse_paragraph(self, m): ...
    def parse_text(self, m): ...

class InlineGrammar:
    escape = ...  # type: Any
    inline_html = ...  # type: Any
    autolink = ...  # type: Any
    link = ...  # type: Any
    reflink = ...  # type: Any
    nolink = ...  # type: Any
    url = ...  # type: Any
    double_emphasis = ...  # type: Any
    emphasis = ...  # type: Any
    code = ...  # type: Any
    linebreak = ...  # type: Any
    strikethrough = ...  # type: Any
    footnote = ...  # type: Any
    text = ...  # type: Any
    def hard_wrap(self): ...

class InlineLexer:
    grammar_class = ...  # type: Any
    default_rules = ...  # type: Any
    inline_html_rules = ...  # type: Any
    renderer = ...  # type: Any
    links = ...  # type: Any
    footnotes = ...  # type: Any
    footnote_index = ...  # type: int
    rules = ...  # type: Any
    def __init__(self, renderer, rules: Optional[Any] = ..., **kwargs) -> None: ...
    def __call__(self, text, rules: Optional[Any] = ...): ...
    def setup(self, links, footnotes): ...
    line_match = ...  # type: Any
    line_started = ...  # type: bool
    def output(self, text, rules: Optional[Any] = ...): ...
    def output_escape(self, m): ...
    def output_autolink(self, m): ...
    def output_url(self, m): ...
    def output_inline_html(self, m): ...
    def output_footnote(self, m): ...
    def output_link(self, m): ...
    def output_reflink(self, m): ...
    def output_nolink(self, m): ...
    def output_double_emphasis(self, m): ...
    def output_emphasis(self, m): ...
    def output_code(self, m): ...
    def output_linebreak(self, m): ...
    def output_strikethrough(self, m): ...
    def output_text(self, m): ...

class Renderer:
    options = ...  # type: Any
    def __init__(self, **kwargs) -> None: ...
    def placeholder(self): ...
    def block_code(self, code, lang: Optional[Any] = ...): ...
    def block_quote(self, text): ...
    def block_html(self, html): ...
    def header(self, text, level, raw: Optional[Any] = ...): ...
    def hrule(self): ...
    def list(self, body, ordered: bool = ...): ...
    def list_item(self, text): ...
    def paragraph(self, text): ...
    def table(self, header, body): ...
    def table_row(self, content): ...
    def table_cell(self, content, **flags): ...
    def double_emphasis(self, text): ...
    def emphasis(self, text): ...
    def codespan(self, text): ...
    def linebreak(self): ...
    def strikethrough(self, text): ...
    def text(self, text): ...
    def escape(self, text): ...
    def autolink(self, link, is_email: bool = ...): ...
    def link(self, link, title, text): ...
    def image(self, src, title, text): ...
    def inline_html(self, html): ...
    def newline(self): ...
    def footnote_ref(self, key, index): ...
    def footnote_item(self, key, text): ...
    def footnotes(self, text): ...

class Markdown:
    renderer = ...  # type: Any
    inline = ...  # type: Any
    block = ...  # type: Any
    footnotes = ...  # type: Any
    tokens = ...  # type: Any
    def __init__(self, renderer: Optional[Any] = ..., inline: Optional[Any] = ..., block: Optional[Any] = ..., **kwargs) -> None: ...
    def __call__(self, text): ...
    def render(self, text): ...
    def parse(self, text): ...
    token = ...  # type: Any
    def pop(self): ...
    def peek(self): ...
    def output(self, text, rules: Optional[Any] = ...): ...
    def tok(self): ...
    def tok_text(self): ...
    def output_newline(self): ...
    def output_hrule(self): ...
    def output_heading(self): ...
    def output_code(self): ...
    def output_table(self): ...
    def output_block_quote(self): ...
    def output_list(self): ...
    def output_list_item(self): ...
    def output_loose_item(self): ...
    def output_footnote(self): ...
    def output_close_html(self): ...
    def output_open_html(self): ...
    def output_paragraph(self): ...
    def output_text(self): ...

def markdown(text, escape: bool = ..., **kwargs): ...
